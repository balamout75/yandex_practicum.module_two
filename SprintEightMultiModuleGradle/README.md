
# Домашняя работа к восьмому спринту курса Java Middle Developer (Yandex Practicum)

# Общая информация
Проект по-прежнему представляет собой **многомодульный Gradle‑проект SprintEightMultiModuleGradle**, состоящий из двух сервисов:

- **ShopCatalogue** — клиентское веб‑приложение магазина
- **ShopPayment** — отдельный HTTP‑платёжный сервис

Архитектура построена на реактивном стеке **Spring WebFlux**, взаимодействие между сервисами осуществляется по HTTP REST. 
В соответствии с заданием текущий проект дополнен реализацией многопользовательского (клиентского) доступа, а также инструментами аутентификации и авторизации, совместимых с системно-концептуальными решениями заданий шестого и сеедьмого спринтов.
Аутентификация. В соответствии с заданием, модуль реализует пользовательскую аутентификацию "OAuth 2.0 Authorization Code Grant + OpenID Connect". Соединение с платежным модулем защищено OAuth 2.0 Resource Server с проверкой JWT access token. В качестве Identity Provider (IdP) используется Keycloak, развернутый в Docker контейнере.
Неавторизованные пользователи имеют доступ к каталогу товаров, но не имеют возможностей пользоваться корзиной, делать заказы и оплачивать их.
Авторизация осуществляется на уровне SecurityWebFilterChain - неавторизованным пользователям закрыты все эндпоинты, кроме Items c модификатором Get. В свою очередь, авторизованным пользователям доступны все эндпоинты, но лиш касательно их собственных заказов, корзин и покупок. UserId не передается в сервисы из контроллеров, а получается из контекста приложения.
В Keycloak зарегистрированы три группы: Clients, Managers и Admin, однако он не были востребованы в контексте работы над проектом.
Межсервисное взаимодействие осуществляется обезличенно, от имени backend-client, наделенного правами Service. Надо сказать, что тема межсервисного взаимодействия осталось не вполне изучена. Изначально я намеревался регистрировать в платжной системе от чьего имени совершались обращения. Однако опыт подобных разработок, щироко распространенный в сети интернет, убедил меня, что аутентификации и авторизации в магазине достаточно. 
Для демонстрации возможностей проекты, разработан стенд docker-compose, поднимающий контейнеры yp-shop, yp-payment, postgres, redis, keycloak, nginx и ngrok. Подробнее об особенностях старта - в последующих разделах описания.

---
# Информация о модулях

## ShopCatalogue - интернет-магазин разных разностей (по умолчанию - порт **8081**).

### Контроллеры

#### CatalogueController (`/items`)
- `GET /items` — витрина товаров  
  Параметры:
    - `search` — поисковая строка
    - `sort` — сортировка (`ALPHA | PRICE | NO`)
    - `pageNumber`, `pageSize` — пагинация

- `GET /items/{id}` — карточка товара

- `POST /items` — изменение количества товара в корзине  
  Параметры:
    - `id`
    - `search`
    - `sort`
    - `pageNumber`, `pageSize`
    - `action` (`PLUS | MINUS | DELETE | NOTHING`)

- `POST /items/{id}` — изменение количества товара из карточки

#### CartController (`/cart`)
- `GET /cart/items` — содержимое корзины
- `POST /cart/items` — изменение количества товара
- `GET /cart/items/{id}` — карточка товара в корзине
- `POST /cart/items/{id}` — управление количеством

#### OrderController (`/orders`)
- `GET /orders` — список заказов
- `GET /orders/{id}` — карточка заказа  
  Параметры:
    - `id` - уникальный номер заказа
    - `newOrder` — признак нового заказа

#### UserController (`/`)
- `GET /` — redirect на `/items`
- `POST /buy` — совершение покупки

---

## ShopPayment (порт **8082**)

Сервис оплаты

### Эндпоинты
- `GET /payment/{userId}/balance` — баланс пользователя
- `POST /payment/{userId}/buy` — оплата заказа
- `GET /swagger-ui/` — Swagger UI

---

## Сборка проекта всего 

```
gradle clean build
```

Команда:
- компилирует проект
- запускает тесты
- генерирует OpenAPI‑файлы
- собирает JAR‑файлы модулей

---

## Тестирование

### Быстрый запуск
```
gradle test
```

---

## Запуск приложения

### Вариант 1 — Docker Compose
```bash
docker compose build
docker compose up
```

Приложение будет доступно по адресу:  
`http://localhost:8081/`

### Вариант 2 — ручной запуск

PostgreSQL:
```bash
docker run --name yp-database --rm --env-file postgres.env -p 5432:5432 -v module_two_postgres_data:/var/lib/postgresql postgres:18.1
```

Redis:
```bash
docker run --name redis-server -it --rm -p 6379:6379 redis/redis-stack-server:latest
```

Для запуска Keycloak надо выполнить в директории KeyCloakContainer основного проекта выполнить команды
- docker compose build 
- docker compose up


Запуск сервисов:
```bash
gradle clean build bootRun
```

Несмотря на то, что сервисы стартуют независимо, рекомендую запускать сначала **ShopPayment**, затем **ShopCatalogue**.
Независимо от выбранного варианта приложение будет доступно по адресу localhost:8081. 
Неавторизованным пользователям доступен каталог товаров, а также возможности пройти авторизацию на сервере Keycloak.

### Демонстрационная учетная запись: ivan/ivan 

В случае контейнерной сборки с использованием внешнего ресурса ngrok (Вариант - 1) при первом запуске, на сайте mgrok необходимо будет подтвердить переход на сторонний вебресурс.

## ВНИМАНИЕ запуск приложения одновременно двумя способами НЕВОЗМОЖЕН .. Задействован один порт 8081   
## ВНИМАНИЕ запуск в Keycloak в докер контейнере, да еще и прокидывание портов, требуют времени ..   

---

## Требования
- **JDK 21**
- Docker / Docker Compose

---

## Реализация и опыт

### Используемые технологии
- Spring Security
- Keycloac
- Ngrok
- Spring Boot 4.0
- Spring WebFlux
- Redis (кэширование)
- PostgreSQL
- OpenAPI
- Testcontainers

### Особенности
   - Версионирование кэша пользовательских каталогов. Никуда я от них не ушел, даже, скорее, укрепился в уверенности в этой технологии. Для изоляции пользовательских (дополненных информацией о наличии в корзине) карточек товаров мне пришлось отказаться от штатного кэширования ItemDto в пользу RedisTemplate. Разобравшись в своих прежних ошибках, я ввел ограничения по времени жизни кэша pageDto, itemDto, userVersion. Дополнительно я ввел кэширование (@Cacheable) профилей прошедщих аутентификацию пользователей, но вынужден был отключить эту опцию из-за нестабильной работы в докер-контейнерах. Пообщавшись м однокурсниками, я пришел к мнению, что можно было бы кэшировать сущности отдельно от персонализированной информации. Страницы витрины и карточки товаров можно кэшировать для всех клиентов, лишь при необходимости дополняя их информацией о наличии в корзине. Это было бы возможно и эффективно средствами Spring Cache. Просто кэшировать на выходе специализированных сервисов. Попробую это в последующих проектах.   
   - Реактивные цепочки без блокировок. Изучил StepVerify. Удалось выровнять цепочки в тестах. 
   - Собственная логика блокировки кнопки «Купить». Оставил, отладил.
   - HTTP‑клиент, сгенерированный OpenAPI, остался без изменений. Хотя я и намеревался разобраться с применением OpenApi в Spring Boot 4 проектах, неделя - это слишком немного.
   - Я постарался, по возможности, документировать рабочие файлы, особенно сервисы. *Примечание*. Методы сервисов в зависимости от назначения носят теперь специальные модификаторы: 
     -  public - методы, доступные из контроллеров. Туда невозможно передать userId, который попадает в сервисы из контекста
     -  pakage-private - методы, доступные из однородных сервисов. Возможна передача userId
     -  private - внутренние вспомогательные сервисы методы 


---

## Игровой режим платежей (UPDATED)

Включается в `application.yaml`.

### Поведение
- Случайный `USER_NOT_FOUND`
- Три равновероятных исхода оплаты:
    - ACCEPTED
    - REJECTED
    - UNAVAILABLE

Неудачные платежи логируются в ShopCatalogue/

---

## Тесты

### ItemControllerIntegrationTest
- Поиск товаров
- Получение товара по ID
- Проверка параметров сортировки и действий
    - пришлось повозиться с кэшем и секьюрити. mutateWith изучил.

### UserServiceLimitedIntegrationTest
- Закрытие корзины
- Создание заказа
- Проверка кэша
    - то же самое

## Тесты я еще попишу. Поскольку дедлайн, пока выложу на ревью ак есть..
---

## Итоги

Работа как и предыдущих четыре получилась насыщенной:
- Работа с Keycloak наводила на мысль поработать с настоящими аутентификационными сервисами Google и Яндекс.. 
- Работа с Keycloak в докерсети упрочила в этой мысли. На то, чтобы уговорить это чудо через прокси, ушло 12 часов непрерывной работы
- Работа с AI разочаровала. Хорошо, когда помощник помогает, сносно, когда не мешает, и совсем никуда не годится, когда пытается завладеть инициативой и еще тупит.
- LiquiBase!!! пришлось модифицировать хранилище Users .. красиво пририсовал ветку !!
- PS. Наконец поработал с профилированием тестов и настроек. Правда в докере различие выродилось, но я пока оставил несколько вариантов настроек, просто для - чтобы помнить.

## Ну что еще, С Наступающим Новым Годом!! 

# А на прощание восьмой модуль подкинул сюрприз.  В тесте забыл MokitoBean, и он подкинул мне несколько NPE в тестах уже после PR.. Надеюсь успел ..
