# Домашняя работа к Седьмому спринту курса Java Middle Developer Yandex Practicum
---
## Что внутри? А внутри многомодульный проект SprintSevenMultiModuleGradle содержащий два сервиса: ShopCatalogue и ShopPayment, первый реализует клиентский интерфейс знакомого нам магазина разных полезностей, а второй - платежную систему. расскажу о них подробнее. 

## ShopCatalogue:
### Реактивные контроллеры

- **CatalogueController** (`/items`):
    - `GET /items` — витрина товаров, параметры:
            search - поисковая строка;
            sort (ALPHA/PRICE/NO) - сортировка товаров;
            pageNumber, pageSize - параметры постраничного отображения.
    - `GET /items/{id}` — карточка товара с соответствующим ID.
    - `POST /items` — изменение количества товаров в корзине, параметры:
            id - уникальный идентификатор товара;
            search - поисковая строка;
            sort (ALPHA/PRICE/NO) - сортировка товаров;
            pageNumber, pageSize - параметры постраничного отображения;
            action (PLUS/MINUS/DELETE/NOTHING) - команды управления счетчиком.
    - `POST /items/{id}` — изменение количества товаров в корзине, параметры:
        id - уникальный идентификатор товара;
        search - поисковая строка;
        action (PLUS/MINUS/DELETE/NOTHING) - команды управления счетчиком.

- **CartController**  (`/cart`):  
    - `GET /cart/items` — отобразить содержимое корзины.
    - `POST /cart/items` — изменить количество товаров в корзине, параметры:
            id - уникальный идентификатор товара;
            action (PLUS/MINUS/DELETE/NOTHING) - команды управления счетчиком.
    - `GET /cart/items/{id}` — карточка товара в корзине:
            id - уникальный идентификатор товара.
    - `POST /cart/items/{id}` — редактировать счетчик количества товаров в корзине, параметры:
              id - уникальный идентификатор товара;
              action (PLUS/MINUS/DELETE/NOTHING) - команды управления счетчиком.

- **OrderController**  (`/orders`):
    - `GET /orders` — получить список заказов.
    - `GET /orders/{id}` — карточка заказа
            id - уникальный идентификатор товара;
            newOrder (true/false) - признак нового заказа 

- **UserController** (`/`):
    - `GET /` — redirect на `GET /items` эндпоинт витрины товаров
    - `POST /buy"` — совершение покупки 

---

## ShopPayment (8081, если иначе не установлено в аpplication.yaml):
### Эндпоинты

- **PaymentController**
    - `GET  /payment/{userId}/balance` — возвращает баланс пользователя. 
    - `POST /payment/{userId}/buy` — производит оплату заказа.
    - `GET  /swagger-ui/` - интерфейс SWAGGER, позволяющий более полно изучит особенности эндпоинтов.  

### Сборка проекта
- Проект собран с использованием Kotlin/Gradle. После клонирования проекта с из репозитория GitHub в основном проекте SprintSevenMultiModuleGradle надо выполнить команду:  
  
 - `gradle clean build` - будет произведена компиляция файлов, запуск тестов, генерация файлов OpenApi и .jar в соответствующих папках модулей ShopCatalogue и ShopPayment.
---
### Быстрый старт (только тесты)

- `gradle test` - запускаем тесты, но не все .. 
- `gradle integrationTest` - PaymentClientIntegrationTest, тест межмодульного взаимодействия запускается специальной командой и выполняется только при включенном сервисе ShopPayment. 
---
### Запуск приложения (1 вариант)

- `docker compose build` - в основной папке проекта выполняем команду сборки образов контейнеров, необходимых для запуска приложения
- `docker compose up` - в основной папке проекта выполняем команду развертывания контейнеров PostgreSQL, Redis, Nginx и сервисов  приложения. Проект становится доступным по адресу 'http://localhost/'  


### Запуск приложения (2 вариант)

- `docker run --name yp-database --rm --net practicum-network --env-file postgres.env -p 5432:5432 -v modile_two_postgres_data:/var/lib/postgresql/18/docker2 postgres:18.1` - в основной папке проекта выполняем команду развертывания и запуска докерконтейнера с PostgreSQL.
- `docker run --name redis-server -it --rm -p 6379:6379 redis/redis-stack-server:latest` - в основной папке проекта выполняем команду развертывания и запуска докерконтейнера с Redis.
- `gradle clean build bootRun` - последовательно запускаем сервисы. Сначала **ShopPayment**, затем **ShopCatalogue**. Приложение поднимает вебсервер, и фронтэнд становится доступен по адресу 'http://localhost:8080/'  
---
### Требования к запуску

- `JDK21` - рабочая среда - JDK21, на более поздних версиях приложение не тестировалось

### Краткое описание 
- Реактивный сайт в стеке WebFlux, дополненный внешним платежным серовисом. Взаимодействие реализовано по протоколу HTTP.
Ключевые технологии определены необходимостью реализовать кэширование (Redis), а также межсервисное взаимодействие. Остроты впечатлений добавила реализация всего на новом фреймворке Spring BOOT 4.0, по каким то причинам выбранным мною для шестой работы, в седьмой я несколько раз пожалел о своем выборе.
Сначала о реализации кэширования. В задачах кэширования все завязано на сериализацию объектов, в четвертом Буте произошли значимые в этом изменения, ушел целый класс конвертеров Jackson2Json, то что вместо них появилось не всегда работает так как надо, там где надо, и если это теперь вообще надо. В общем рконфигурации Redis в конце концов получились, и в реализациях я сделал закономерный цикл: ключи, хэши, CRUDrepo, темплейты и снова хэши, остановился на том, что понравилось.
OpenAPI тоже дало поразвлечься, из-за несовершенства генератора 7.17 я не смог оставить генерацию клиента, его было необходимо править, но вот сервер получился, и мне даже понравилось. Вижу как дополнить протокол взаимодействия в следующей работе.

### Изменения в сравнении с работой шестого спринта
- Очень интересная **жирная** работа. Учел замечания по итогам шестой. Объемы работы просто удивили. Я надеялся, к Новому году будет полегче.

### Что понравилось
- Redis
- OpenAPI
- Spring BOOT 4.0
- ChatGPT... наконец то я открыл для себя этот ящик Пандоры. Я занимался вопросами ИИ, и даже диссер защитил по машинному выводу нцать лет назад, но что станет все вот так, я не ожидал.

### Что сделал .. 
- Мне понравилась собственная реализация блокировки кнопки "Купить". Если покупка возможна, кнопка разблокирована. Если по нажатию покупка не совершилась - логируем причину отказа и возвращаемся в корзину. Причина блокировки кнопки объяснит причину и несовершенной и отсутствия возможности нажать на кнопку.
- Да, отладил реактивные цепочки. Это залипательно, особенно когда получается лучше чем у ИИ.

### Что не сделал .. 
- Не довел до ума сценарии платежного сервиса, может, сделаю это в восьмой работе, а может и завтра, хотя хотел бы уже от этой работы отдохнуть. У меня есть тест межсервисного взаимодействия, и им можно поиграться, и всякие случайности можно придумать, и включить генератор значений по ключу в application.yaml.
- Кое-где шалит сортировка товаров на страницах. 
---

## Тестирование
По тестированию. Тестирование было интересным. Я честно попробовал embedded Redis, и больше c ними связываться не хочу, со всеми тремя ). Относительно Testcontainers, пришел к каноническому варианту применения абстрактного класса. Пришлось повозиться с PaymentClientIntegrationTest, этот тест при clean build конечно же не срабатывает, пришлось заморочиться чтобы его отключить. А вообще да.. подошел к необходимости профилирования приложения..

### Что внутри

- **ItemControllerIntegrationTest** - относительно шестой работы ничего не изменилось ..
    - `findItemsByTitleOrDescription` — интеграционный тест на поиск товаров по названию или описанию
    - `getItemByIdSuccesfull` — интеграционный тест на поиск товара с корректным ID
    - `getItemByIdNotFound` — интеграционный тест на поиск товара с несуществующим ID
    - `testRequestSortParameterConverter` — модульный тест обработки параметров сортировки (string-ENUM)
    - `testRequestActionParameterConverter` — модульный тест обработки параметров управления счетчиком

- **UserServiceLimitedIntegrationTest** - пришлось косвенно протестировать еще и кэш, так что тестирование кэша в каком то виде реалищовано.
    - `testCloseChartByUserId` — интеграционный тест на взаимодействие уровня логики и DAO. Отработка сценария "Закрытие корзины и создание нового заказа"
    - `testChangeInCardCount` — сценарий "корректировка состава покупательской корзины" 

- **UserServiceLimitedIntegrationTest** - пришлось косвенно протестировать еще и кэш, так что тестирование кэша в каком то виде реалищовано.
    - `testCloseChartByUserId` — интеграционный тест на взаимодействие уровня логики и DAO. Отработка сценария "Закрытие корзины и создание нового заказа"
    - `testChangeInCardCount` — сценарий "корректировка состава покупательской корзины"
      
- **PaymentClientIntegrationTest** -
    - `getBalance_succes` - успешный запрос баланса
    - `getBalance_userNotFound` - баланс отсутствующего пользователя
    - `buy_success` - успешная покупка
    - `buy_userNotFound` - пользователь не существует
    - `buy_serviceUnavailable` - сервис не доступен
    - `buy_refused` - деньги кончились в процессе - INCOMING 
