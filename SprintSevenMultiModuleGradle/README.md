# Домашняя работа к Седьмому спринту курса Java Middle Developer Yandex Practicum
---
## Что внутри? А внутри многомодульный проект SprintSevenMultiModuleGradle содержащий два сервиса: ShopCatalogue и ShopPayment, первый реализует клиентский интерфейс знакомого нам магазина разных полезностей, а второй - платежную систему. расскажу о них подробнее. 

## ShopCatalogue:
### Реактивные контроллеры

- **CatalogueController** (`/items`):
    - `GET /items` — витрина товаров, параметры:
            search - поисковая строка;
            sort (ALPHA/PRICE/NO) - сортировка товаров;
            pageNumber, pageSize - параметры постраничного отображения.
    - `GET /items/{id}` — карточка товара с соответствующим ID.
    - `POST /items` — изменение количества товаров в корзине, параметры:
            id - уникальный идентификатор товара;
            search - поисковая строка;
            sort (ALPHA/PRICE/NO) - сортировка товаров;
            pageNumber, pageSize - параметры постраничного отображения;
            action (PLUS/MINUS/DELETE/NOTHING) - команды управления счетчиком.
    - `POST /items/{id}` — изменение количества товаров в корзине, параметры:
        id - уникальный идентификатор товара;
        search - поисковая строка;
        action (PLUS/MINUS/DELETE/NOTHING) - команды управления счетчиком.

- **CartController**  (`/cart`):  
    - `GET /cart/items` — отобразить содержимое корзины.
    - `POST /cart/items` — изменить количество товаров в корзине, параметры:
            id - уникальный идентификатор товара;
            action (PLUS/MINUS/DELETE/NOTHING) - команды управления счетчиком.
    - `GET /cart/items/{id}` — карточка товара в корзине:
            id - уникальный идентификатор товара.
    - `POST /cart/items/{id}` — редактировать счетчик количества товаров в корзине, параметры:
              id - уникальный идентификатор товара;
              action (PLUS/MINUS/DELETE/NOTHING) - команды управления счетчиком.

- **OrderController**  (`/orders`):
    - `GET /orders` — получить список заказов.
    - `GET /orders/{id}` — карточка заказа
            id - уникальный идентификатор товара;
            newOrder (true/false) - признак нового заказа 

- **UserController** (`/`):
    - `GET /` — redirect на `GET /items` эндпоинт витрины товаров
    - `POST /buy"` — совершение покупки 

---

## ShopPayment (8081, если иначе не установлено в аpplication.yaml):
### Эндпоинты

- **PaymentController**
    - `GET  /payment/{userId}/balance` — возвращает баланс пользователя. 
    - `POST /payment/{userId}/buy` — производит оплату заказа.
    - `GET  /swagger-ui/` - интерфейс SWAGGER, позволяющий более полно изучит особенности эндпоинтов.  

### Сборка проекта
- Проект собран с использованием Kotlin/Gradle. После клонирования проекта с из репозитория GitHub в основном проекте SprintSevenMultiModuleGradle надо выполнить команду:  
  
 - `gradle clean build` - будет произведена компиляция файлов, запуск тестов, генерация файлов OpenApi и .jar в соответствующих папках модулей ShopCatalogue и ShopPayment.
---
### Быстрый старт (только тесты)

- `gradle test` - запускаем тесты, но не все .. 
- `gradle integrationTest` - PaymentClientIntegrationTest, тест межмодульного взаимодействия запускается специальной командой и выполняется только при включенном сервисе ShopPayment. 
---
### Запуск приложения (1 вариант)

- `docker compose build` - в основной папке проекта выполняем команду сборки образов контейнеров, необходимых для запуска приложения
- `docker compose up` - в основной папке проекта выполняем команду развертывания контейнеров PostgreSQL, Redis, Nginx и сервисов  приложения. Проект становится доступным по адресу 'http://localhost/'  


### Запуск приложения (2 вариант)

- `docker run --name yp-database --rm --net practicum-network --env-file postgres.env -p 5432:5432 -v modile_two_postgres_data:/var/lib/postgresql/18/docker2 postgres:18.1` - в основной папке проекта выполняем команду развертывания и запуска докерконтейнера с PostgreSQL.
- `docker run --name redis-server -it --rm -p 6379:6379 redis/redis-stack-server:latest` - в основной папке проекта выполняем команду развертывания и запуска докерконтейнера с Redis.
- `gradle clean build bootRun` - последовательно запускаем сервисы. Сначала **ShopPayment**, затем **ShopCatalogue**. Приложение поднимает вебсервер, и фронтэнд становится доступен по адресу 'http://localhost:8080/'  
---
### Требования к запуску

- `JDK21` - рабочая среда - JDK21, на более поздних версиях приложение не тестировалось
  

### Краткое описание 
- Реактивный сайт в стеке WebFlux. Очень понравилось, поработал бы с этой технологией еще и профессионально. Очень напомнило старый добрый Lisp и Prolog, я на них учился.  
- Для связи корзины и заказов пришлось придумать новую сущность - _**(User)**_ Пользователя. Да, это нарушение YAGNI, но так проще. (Это осталось со предыдущего задания )
- Под Вашим влиянием переписал пятую работу, и здесь тоже внимательнее отнесся к проектированию слоя сервисов, в основном для избежания циклических зависимостей.  
- В целом, реактивные репозитории несколько .. требуют к себе внимания. О них МАЛО написано. 
- В ChartService пришлось повозиться с сортировкой товаров на витрине. Декартово произведение списка товаров и состава корзины отчего-то нарушило порядок товаров. Пришлось упорядочивать компаратором, благо, что на странице их немного, но надо будет еще посмотреть, почему так получилось.
- Да .. мне пришлось поменять модель :) Изначально я решил схитрить, и много всего делал на уровне СУБД. Это порождало новые сущности, вроде "товара с количеством его в корзине пользователя", но после того, как репозиторий отказался со всем этим нормально работать, пришлось все вернуть к каноническим истокам. Но к тому времени я уже умел функционально "вязать" отношения, и это даже понравилось.   
- По умолчанию на странице товаров сортировка отключена, я ставил сортировку по id, чтобы содержимое не скакало, но потом убрал, в соответствии с ТЗ. Вернуть несложно!
   
---

### Изменения в сравнении с работой пятого спринта
- Очень интересная **жирная** работа  

### Что понравилось
- Redis
- R2DBC

---

## Тестирование
По тестированию. Я опять ограничил себя в творчестве тестов. Надо как-то научиться совмещать написание кода и тестов к нему 

### Что внутри

- **ItemControllerIntegrationTest** 
    - `findItemsByTitleOrDescription` — интеграционный тест на поиск товаров по названию или описанию
    - `getItemByIdSuccesfull` — интеграционный тест на поиск товара с корректным ID
    - `getItemByIdNotFound` — интеграционный тест на поиск товара с несуществующим ID
    - `testRequestSortParameterConverter` — модульный тест обработки параметров сортировки (string-ENUM)
    - `testRequestActionParameterConverter` — модульный тест обработки параметров управления счетчиком

- **UserServiceLimitedIntegrationTest**
    - `testCloseChartByUserId` — интеграционный тест на взаимодействие уровня логики и DAO. Отработка сценария "Закрытие корзины и создание нового заказа"
    - `testChangeInCardCount` — сценарий "корректировка состава покупательской корзины" 

Еще допишу