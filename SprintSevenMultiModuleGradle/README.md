# Работа над ошибками к домашней работе к Седьмому спринту курса Java Middle Developer (Yandex Practicum)

Что сделал:
1) Исправил тесты! Мне совершенно стыдно, но тесты к PaymentService я прокараулил. Логику изменил, а тесты не переписал и не проверил. Действительно торопился.

2) Ввел Spring Security. Теперь анонимный пользователь =
              .anonymous(anonymous -> anonymous
              .principal(new UserPrincipal(1L))
   - В контроллеры значение попадает через параметры методов эндпоинтов: @AuthenticationPrincipal UserPrincipal user
   - Я не уверен, что это так правильно, но в следующей задаче обещаю разобраться, там, я так чувствую, должны быть и предусловия и постусловия на уровне методов.
   - Проделанная работа хорошо легла на прочитанный материал восьмого спринта и здорово продвинула в выполнении итогового задания.
   - 
3) Развел реализации интерфейса PaymentValidationService по условию, как ты и рекомендовал.

4) Реализовал таймауты для HTTP-клиента и настройки retry-политики. Я как то проглядел это в учебном курсе, с удовольствием разобирался. Мне показалось, что межсервисное взаимодействие у меня пока неидеально. В следующей работе я сделаю ENUM контроль ходимых между сервисами сообщений. Я хочу еще подумать, какие события стоит ретраить, а какие нет. Текущее решение я оцениваю как демонстрационное.

5) По кэшированию. Я честно перерабатывал проект. Сочетание ReactiveHashOperations и @CacheEvict у меня не сработало. Погуглил - причина в смешении методов, Спрингкэш не знает о моих низкоуровневых действиях.
Пробовал кэшировать @Casheable Mono<List<ItemDto>>, это сработало, но показалось мне не перспективным. Я и так довольно примитивно работаю с кэшем, в сравнении с работами Станислава, удалять кэши всех пользователей, если только один внес изменение в корзине, стоит ли так делать? Я довольно долго разбирался с кэшами, тут и четверка наложилась, и собственная глупость. Хотел и через репо искать закэшированные страницы, где есть измененные элементы корзины. Потом оказалось, что реактивного репо для рэдиса не существует. 
Версирование показалось мне классным решением обновления страниц, потому что я могу дифференцировать версии по пользователям. И, главное, это дешевая операция, - инкрементировал версию - и ничего не надо удалять, само истечет со временем. Можно я оставлю версирование? Иначе мне придется в восьмой работе на template переходить, а это еще ниже уровень ((   

Цитата: Вместо ручного управления версиями через Redis используй аннотацию @CacheEvict с параметром allEntries=true при изменении корзины. 
Так просто у меня это не получилось. Оно мой page, созданный в ReactiveHashOperations не удаляет ..
    @Caching(evict = {
        @CacheEvict(cacheNames = "item", key = "#userId + '-' + #itemId"),
        @CacheEvict(cacheNames = "page", allEntries = true)
Ну, то есть, я хочу сохранить возможность определять логику удаления кэшированных страниц, главным образом для того, чтобы хорошо отработать в восьмой работе. И .. версирование мне интересно, я тут засыпался на собесе по оптимистическим блокировкам. 

6) Сделал упорядочение Item в корзине по itemId, просто потому, что иначе содержимое корзины имело свойство скакать при обновлении окна. До ордеров пока руки не дошли.
7) С пулреквестами надо еще поразбираться



# Домашняя работа к Седьмому спринту курса Java Middle Developer (Yandex Practicum)

## Общая информация
Проект представляет собой **многомодульный Gradle‑проект SprintSevenMultiModuleGradle**, состоящий из двух сервисов:

- **ShopCatalogue** — клиентское веб‑приложение магазина
- **ShopPayment** — отдельный HTTP‑платёжный сервис

Архитектура построена на реактивном стеке **Spring WebFlux**, взаимодействие между сервисами осуществляется по HTTP.

---

## ShopCatalogue

### Контроллеры

#### CatalogueController (`/items`)
- `GET /items` — витрина товаров  
  Параметры:
    - `search` — поисковая строка
    - `sort` — сортировка (`ALPHA | PRICE | NO`)
    - `pageNumber`, `pageSize` — пагинация

- `GET /items/{id}` — карточка товара

- `POST /items` — изменение количества товара в корзине  
  Параметры:
    - `id`
    - `search`
    - `sort`
    - `pageNumber`, `pageSize`
    - `action` (`PLUS | MINUS | DELETE | NOTHING`)

- `POST /items/{id}` — изменение количества товара из карточки

#### CartController (`/cart`)
- `GET /cart/items` — содержимое корзины
- `POST /cart/items` — изменение количества товара
- `GET /cart/items/{id}` — карточка товара в корзине
- `POST /cart/items/{id}` — управление количеством

#### OrderController (`/orders`)
- `GET /orders` — список заказов
- `GET /orders/{id}` — карточка заказа  
  Параметры:
    - `id`
    - `newOrder` — флаг нового заказа

#### UserController (`/`)
- `GET /` — redirect на `/items`
- `POST /buy` — совершение покупки

---

## ShopPayment

Сервис оплаты (по умолчанию порт **8081**).

### Эндпоинты
- `GET /payment/{userId}/balance` — баланс пользователя
- `POST /payment/{userId}/buy` — оплата заказа
- `GET /swagger-ui/` — Swagger UI

---

## Сборка проекта

```bash
gradle clean build
```

Команда:
- компилирует проект
- запускает тесты
- генерирует OpenAPI‑файлы
- собирает JAR‑файлы модулей

---

## Тестирование

### Быстрый запуск
```bash
gradle test
```

### Интеграционные тесты
```bash
gradle integrationTest
```

`PaymentClientIntegrationTest` выполняется только при включённом сервисе ShopPayment.

---

## Запуск приложения

### Вариант 1 — Docker Compose
```bash
docker compose build
docker compose up
```

Приложение будет доступно по адресу:  
`http://localhost/`

### Вариант 2 — ручной запуск

PostgreSQL:
```bash
docker run --name yp-database --rm --env-file postgres.env -p 5432:5432 -v module_two_postgres_data:/var/lib/postgresql postgres:18.1
```

Redis:
```bash
docker run --name redis-server -it --rm -p 6379:6379 redis/redis-stack-server:latest
```

Запуск сервисов:
```bash
gradle clean build bootRun
```

Сначала **ShopPayment**, затем **ShopCatalogue**.

---

## Требования
- **JDK 21**
- Docker / Docker Compose

---

## Реализация и опыт

### Используемые технологии
- Spring Boot 4.0
- Spring WebFlux
- Redis (кэширование)
- PostgreSQL
- OpenAPI
- Testcontainers

### Особенности
- Версионирование кэша пользователя
- Реактивные цепочки без блокировок
- Собственная логика блокировки кнопки «Купить»
- HTTP‑клиент, сгенерированный OpenAPI

---

## Игровой режим платежей (UPDATED)

Включается в `application.yaml`.

### Поведение
- Случайный `USER_NOT_FOUND`
- Три равновероятных исхода оплаты:
    - ACCEPTED
    - REJECTED
    - UNAVAILABLE

Неудачные платежи логируются.

---

## Тесты

### ItemControllerIntegrationTest
- Поиск товаров
- Получение товара по ID
- Проверка параметров сортировки и действий

### UserServiceLimitedIntegrationTest
- Закрытие корзины
- Создание заказа
- Проверка кэша

### PaymentClientIntegrationTest
- Успешная оплата
- Пользователь не найден
- Сервис недоступен

---

## Итоги

Работа получилась насыщенной:
- Redis и OpenAPI добавили сложности
- Spring Boot 4.0 местами оказался «сыроват»
- Реактивная модель дала хороший опыт

