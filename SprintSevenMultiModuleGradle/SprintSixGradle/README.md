# Домашняя работа к шестому спринту курса Java Middle Developer Yandex Practicum
---
## Что внутри
### Реактивные контроллеры

- **ItemController** (`/items`):
    - `GET /items` — витрина товаров, параметры:
            search - поисковая строка;
            sort (ALPHA/PRICE/NO) - сортировка товаров;
            pageNumber, pageSize - параметры постраничного отображения.
    - `GET /items/{id}` — карточка товара с соответствующим ID.
    - `POST /items` — изменение количества товаров в корзине, параметры:
            id - уникальный идентификатор товара;
            search - поисковая строка;
            sort (ALPHA/PRICE/NO) - сортировка товаров;
            pageNumber, pageSize - параметры постраничного отображения;
            action (PLUS/MINUS/DELETE/NOTHING) - команды управления счетчиком.
    - `POST /items/{id}` — изменение количества товаров в корзине, параметры:
        id - уникальный идентификатор товара;
        search - поисковая строка;
        action (PLUS/MINUS/DELETE/NOTHING) - команды управления счетчиком.

- **CartController**  (`/cart`):  
    - `GET /cart/items` — отобразить содержимое корзины.
    - `POST /cart/items` — изменить количество товаров в корзине, параметры:
            id - уникальный идентификатор товара;
            action (PLUS/MINUS/DELETE/NOTHING) - команды управления счетчиком.
    - `GET /cart/items/{id}` — карточка товара в корзине:
            id - уникальный идентификатор товара.
    - `POST /cart/items/{id}` — редактировать счетчик количества товаров в корзине, параметры:
              id - уникальный идентификатор товара;
              action (PLUS/MINUS/DELETE/NOTHING) - команды управления счетчиком.

- **OrderController**  (`/orders`):
    - `GET /orders` — получить список заказов.
    - `GET /orders/{id}` — карточка заказа
            id - уникальный идентификатор товара;
            newOrder (true/false) - признак нового заказа 

- **UserController** (`/`):
    - `GET /` — redirect на `GET /items` эндпоинт витрины товаров
    - `POST /buy"` — совершение покупки 

---
### Сборка проекта
- Проект собран с использованием Kotlin/Gradle. Думаю, цикл я замкнул, в следующей работе вернусь в Maven
  
 - `gradle clean build` - компилирует файлы, запускает тесты и генерирует файл .jar в папке build/lib/
---
### Быстрый старт (только тесты)

- `gradle test`  - запускаем тесты
---
### Запуск приложения (1 вариант)

- `docker compose build` - в папке проекта выполняем команду сборки образов контейнеров, необходимых для запуска приложения
- `docker compose up` - в папке проекта выполняем команду развертывания контейнеров PostgreSQL, Nginx и приложения. Проект становится доступным по адресу 'http://localhost/'  


### Запуск приложения (2 вариант)

- `docker run --name yp-database --rm --net practicum-network --env-file postgres.env -p 5432:5432 -v modile_two_postgres_data:/var/lib/postgresql/18/docker2 postgres:18.1` - в папке проекта выполняем команду развертывания и запуска докерконтейнера с PostgreSQL.
- `gradle clean build bootRun` - запускаем приложение. Приложение поднимает вебсервер, и фронтэнд становится доступен по адресу 'http://localhost:8080/'  
---
### Требования к запуску

- `JDK21` - рабочая среда - JDK21, на более поздних версиях приложение не тестировалось
  

### Краткое описание
- Реактивный сайт в стеке WebFlux. Очень понравилось, поработал бы с этой технологией еще и профессионально. Очень напомнило старый добрый Lisp и Prolog, я на них учился.  
- Для связи корзины и заказов пришлось придумать новую сущность - _**(User)**_ Пользователя. Да, это нарушение YAGNI, но так проще. (Это осталось со предыдущего задания )
- Под Вашим влиянием переписал пятую работу, и здесь тоже внимательнее отнесся к проектированию слоя сервисов, в основном для избежания циклических зависимостей.  
- В целом, реактивные репозитории несколько .. требуют к себе внимания. О них МАЛО написано. 
- В ChartService пришлось повозиться с сортировкой товаров на витрине. Декатрово произведение списка товаров и состава корзины отчего-то нарушило порядок товаров. Пришлось упорядочивать компаратором, благо, что на странице их немного, но надо будет еще посмотреть, почему так получилось.
- Да .. мне пришлось поменять модель :) Изначально я решил схитрить, и много всего делал на уровне СУБД. Это порождало новые сущности, вроде "товара с количеством его в корзине пользователя", но после того, как репозиторий отказался со всем этим нормально работать, пришлось все вернуть к каноническим истокам. Но к тому времени я уже умел функционально "вязать" отношения, и это даже понравилось.   
- По умолчанию на странице товаров сортировка отключена, я ставил сортировку по id, чтобы содержимое не скакало, но потом убрал, в соответствии с ТЗ. Вернуть несложно!
  **UPDATED!!** Включил сортировку по id для товаров как вариант по умолчанию. Иначе картинки скачуть.. 
---

### Что не удалось
- Не подогнал картнки по размеру, **опять** не успел
- @Transactional и @SQL в тестах совершенно не получились. Надо еще с ними поразбираться.

### Изменения в сравнении с работой пятого спринта
- Много интересного кода, хороший контроль результата 

### Что понравилось
- WebFlux
- R2DBC

---

## Тестирование
По тестированию. Я опять ограничил себя в творчестве тестов. Надо как-то научиться совмещать написание кода и тестов к нему 

### Что внутри

- **ItemControllerIntegrationTest** 
    - `findItemsByTitleOrDescription` — интеграционный тест на поиск товаров по названию или описанию
    - `getItemByIdSuccesfull` — интеграционный тест на поиск товара с корректным ID
    - `getItemByIdNotFound` — интеграционный тест на поиск товара с несуществующим ID
    - `testRequestSortParameterConverter` — модульный тест обработки параметров сортировки (string-ENUM)
    - `testRequestActionParameterConverter` — модульный тест обработки параметров управления счетчиком

- **UserServiceLimitedIntegrationTest**
    - `testCloseChartByUserId` — интеграционный тест на взаимодействие уровня логики и DAO. Отработка сценария "Закрытие корзины и создание нового заказа"
    - `testChangeInCardCount` — сценарий "корректировка состава покупательской корзины" 
